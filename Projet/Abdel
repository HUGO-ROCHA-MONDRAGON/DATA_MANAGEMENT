
import numpy as np

import sqlite3
import pandas as pd
import numpy as np

def strategie_portefeuille_montecarlo(
    db_file: str,
    risk_type: str = "LOW_RISK",
    num_simulations: int = 200,
    num_days: int = 7,
    target_volatility: float = 0.10,
    max_budget: float = 5_000_000
):
    # Connexion et récupération des tickers et quantités existants
    conn = sqlite3.connect(db_file)
    query_portfolio = """
        SELECT TICKER, QUANTITY
        FROM Portfolios
        WHERE RISK_TYPE = ?
    """
    portfolio_df = pd.read_sql_query(query_portfolio, conn, params=(risk_type,))
    
    if portfolio_df.empty:
        return(f"Aucun actif trouvé pour le profil de risque '{risk_type}'. Vérifie l'orthographe.")

    tickers = portfolio_df['TICKER'].tolist()
    
    # Récupérer les prix historiques depuis la table Products
    price_data = {}
    for ticker in tickers:
        query_prices = """
            SELECT IMPORT_DATE, PRICE
            FROM Products
            WHERE TICKER = ?
            ORDER BY IMPORT_DATE ASC
        """
        df = pd.read_sql_query(query_prices, conn, params=(ticker,))
        df['IMPORT_DATE'] = pd.to_datetime(df['IMPORT_DATE'], dayfirst=True)
        df.set_index('IMPORT_DATE', inplace=True)
        price_data[ticker] = df['PRICE']
    conn.close()

    # Créer un DataFrame aligné des prix
    prices_df = pd.concat(price_data.values(), axis=1)
    prices_df.columns = tickers
    prices_df.dropna(inplace=True)

    # Calcul des rendements log
    log_returns = np.log(prices_df / prices_df.shift(1)).dropna()
    mean_returns = log_returns.mean()
    cov_matrix = log_returns.cov()

    # Simuler des portefeuilles
    results = []
    for _ in range(num_simulations):
        weights = np.random.random(len(tickers))
        weights /= np.sum(weights)
        
        # Calcul rendement et volatilité du portefeuille simulé
        port_return = np.sum(mean_returns * weights) * num_days
        port_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix * num_days, weights)))

        # Récupérer le dernier prix spot
        latest_prices = prices_df.iloc[-1].values
        quantites = np.floor((weights * max_budget) / latest_prices)
        total_value = np.sum(quantites * latest_prices)

        if port_vol <= target_volatility and total_value <= max_budget:
            results.append({
                'weights': weights,
                'quantities': quantites.astype(int),
                'volatility': port_vol,
                'expected_return': port_return,
                'total_cost': total_value
            })

    # Choisir le portefeuille optimal : celui avec max return et coût minimal
    if not results:
        return "Aucun portefeuille trouvé respectant les contraintes."
    
    # Trier par return décroissant puis coût croissant
    sorted_results = sorted(results, key=lambda x: (-x['expected_return'], x['total_cost']))
    best_portfolio = sorted_results[0]

    # Retourner les quantités optimales associées aux tickers
    optimal_quantities = dict(zip(tickers, best_portfolio['quantities']))
    optimal_quantities['expected_return'] = best_portfolio['expected_return']
    optimal_quantities['volatility'] = best_portfolio['volatility']
    optimal_quantities['total_cost'] = best_portfolio['total_cost']

    return optimal_quantities

strategie_portefeuille_montecarlo( db_file, "LOW_RISK", 200, 7, 0.10 , 5000000 )

